<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[极验滑动验证码行为模拟]]></title>
    <url>%2F2018%2F10%2F01%2F%E6%9E%81%E9%AA%8C%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E8%A1%8C%E4%B8%BA%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[为了能看到具体的效果，使用了selenium+chrome进行实验，如果大家想要打包下载即用，可以自行修改搭配PhantomJS食用。经过一番折腾成功率已经比较高了（70%-90%吧【2018/10/01】），某些背景干扰元素过多缺口又刚好在色差较小的地方的时候可能会计算错误，也可能还有某些特殊的情况，GIF是旧的，具体可看MP4。 代码仅供参考学习交流，有兴趣可以拿去玩玩，鉴于本人能力有限，代码、逻辑以及解决方式上有错误在所难免，请各位大佬多多指教~另外我发现极验官网快改版了，鉴于该代码直接在极验官网上模拟，可能很快就用不了了，届时可以考虑接入api到自己本地再进行模拟测试。 仓库地址: https://github.com/tomhaoye/geetest-crack-demo 故事起源之前写了个爬虫抓取58的小区数据的代码，有人提了个issue，说小区详情数据和经纬度为空，我自己试了一把，发现请求太频繁会被强制跳转到验证码的页面去。 后来试用了代理，发现一个ip没抓几条数据就被强制跳转人机校验了，然后我手动去访问网页并通过验证码的校验之后再去抓取数据，发现抓取了几千条数据也没有再被强跳了。 这是什么规则=。=算了，还是先想办法能自动通过人机校验先。而58的这个页面的人机校验，是类似于极验的那种滑动验证码。emmmm，网上资料都很多，但是版本较旧，现在的极验滑动校验改进了不少地方，不过思路总是可以参考了。 步骤分解 屏幕出现滑动行为验证码框 截取验证码合成图片\获取验证码原图片 图片处理以及缺口定位 将拼图移动到缺口处 开始研究0、屏幕出现滑动行为验证码框我首先找到使用极验控件的地方，例如：极验官网，然后点击到滑动行为验证框出现。这个行为使用selenium模拟比较简单，关于如何使用selenium进行元素定位、模拟点击等这里就不多介绍了，有需要学习的找谷歌百度皆可，有前端基础的一小时内就能够上手。 1、截取验证码合成图片\获取验证码原图片1.1、获取验证码原图片现在滑动行为验证框已经出现了，接下来应该是想办法拿到原图片，或者是直接截取当前合成好的图片，两种做法有本质上什么区别呢？首先先说一下获得原图片，极验在加载校验控件的时候会请求三张图片，其中一张是缺口原图，另外一张是完整原图，还有一张是拼块。 缺口原图 完整原图 大家可以看到，请求的所获取到的原图，都是打散重组过的图片，我读过一些解析的文章，有的提到重新组合到一起的方法写在代码里面，而有的文章则是表示散块映射关系是有接口请求的，这也许是大家研究的版本不一样所导致的。我下载了一些原图的组合进行了观察，倒是发现了每一组原图的其实打散前后的散块的位置应该是固定的，也就是说映射关系应该是固定的。其实我觉得，无论映射关系是在前端代码里，还是在接口里，只要你需要在客户端进行重组的，那就相当于没有秘密，所以多一事不如少一事，直接使用固定的映射关系倒是省事不少。 1.2、截取验证码合成图片这一小节是关于获取图片的，图片处理会在下一小节，所以接下来说一下直接截取合成的图片。所谓所见即所得，能够获取到人眼直接看到的图像，才是最接近人类行为的模拟，而如果通过其他方式取巧，哪天他的方式改了，你的逻辑就不适用了。就像我后来观察58的滑动行为验证，它家请求的图片就是完整的合成图，所以遵循正常人类行为才是究极奥义啊。至于如何截取动行为验证框中的合成图片，我们需要定位到验证框所属的位置，于是乎我先定位到一个class为geetest_window的div，拿到它当前的位置以及长宽属性，接着截图整个当前页面的，并根据刚刚获得的位置以及长宽属性对当前页面图片进行裁剪，就可以获得我们人眼所看到的合成图片了。 def cut_gt_window_image(browser): image_div = browser.find_element_by_class_name(&quot;geetest_window&quot;) location = image_div.location size = image_div.size top, bottom, left, right = location[&#39;y&#39;], location[&#39;y&#39;] + size[&#39;height&#39;], location[&#39;x&#39;], location[&#39;x&#39;] + size[ &#39;width&#39;] screen_shot = browser.get_screenshot_as_png() screen_shot = image.open(BytesIO(screen_shot)) captcha = screen_shot.crop((left, top, right, bottom)) captcha.save(cut_image_path) return browser 合成图片 通过这一小节我们对于获取图片的方式和方法已经了然于胸，现在就让我们进入下一小节，对刚刚所获得的图片进行分析和研究吧。 2、图片处理以及缺口定位2.1、处理打散的原图片与定位缺口位置 在上一小节，我们已经猜测过是打散过的图片跟实际上正常的图片的映射关系是固定的，所以我先尝试对其中一张缺口原图的打散图片进行重组。重组的关键其实就是找到散块跟原来位置的映射关系就行了，于是我拿着打散图片跟合成好的图片一块一块的对比，发现了它实际上是将正常的图片分为上下两部分，然后上下两部分再分为26份进行打散的。关于位置的映射关系，由于时间关系，我就动用了我的火眼金睛直接得到了结果： {1: 18, 2: 17, 3: 15, 4: 16, 5: 22, 6: 21, 7: 14, 8: 13, 9: 10, 10: 9, 11: 19, 12: 20, 13: 2, 14: 1, 15: 6, 16: 5, 17: 26, 18: 25, 19: 23, 20: 24, 21: 7, 22: 8, 23: 3, 24: 4, 25: 11, 26: 12} 这里的映射关系是图片上半部分的，而下半部分的映射关系，我找了前两个散块的原本对应位置，就大概能猜到其实就是使用上半部分的映射关系相邻两值交换后的结果，例如上半部分是1:18, 2:17那么到了下半部分就是1:17, 2:18，下面就是具体的还原图片代码： def merge_img(img_path=&#39;&#39;, target=&#39;&#39;): im = image.open(img_path) to_image = image.new(&#39;RGB&#39;, (260, 160)) dx = 12 dy = 80 x = 0 img_map = {1: 18, 2: 17, 3: 15, 4: 16, 5: 22, 6: 21, 7: 14, 8: 13, 9: 10, 10: 9, 11: 19, 12: 20, 13: 2, 14: 1, 15: 6, 16: 5, 17: 26, 18: 25, 19: 23, 20: 24, 21: 7, 22: 8, 23: 3, 24: 4, 25: 11, 26: 12} while x &lt;= 300: y = 0 while y &lt;= 80: from_img = im.crop((x, y, x + dx, y + dy)) second_line = img_map[(x / 12) if ((x / 12) % 2) else (x / 12 + 2)] - 1 loc = ((img_map[x / 12 + 1] - 1) * 10 if y else second_line * 10, abs(y - dy)) to_image.paste(from_img, loc) y += dy x += dx to_image = to_image.convert(&#39;L&#39;) to_image.save(target) return to_image 补充一点，大家看到的打散图片的宽度是312个像素的，而我这里最后还原的得到的图片宽度却是260像素，这是因为打散图片的每一个相邻散块之间实际上是有重叠部分的，一开始我合成得到的宽度312像素的图片时候发现图片是变了样的，所以最后将他们重叠部分堆叠在一起，才得到了正常的原始图片。 还原完整图片 还原缺口图片 缺口图和完整图都可以如法炮制，最后为了方便对比，进行了灰度化处理。接下来由于自身对各种图片格式并不熟悉，碰了不少壁，我会另外再写一篇关于图片格式的学习笔记，完工后会把链接贴过来，有需要的童鞋可以自取，这里我就不详细说自己怎么坑自己的了。 那我们来进入正题，两张完整的图片已经到手了，接下来就应该是定位缺口的起始位置了。童鞋们可以用肉眼看到，两张图片除了缺口位置，其他部分基本是完全一样的，所以思路很简单，就是对两张图片逐个像素点进行对比，然后第一个有差别的位置，是不是就是缺口的起始位置呢？ 换作先前的版本或许是对的，但现在来说大概是错的，为什么这么说呢？比较多前辈的文章中提到第一个差异的位置就是缺口的起点，但是那是基于打散图片后使用的压缩标准是无损压缩，如果使用了有损压缩（或者说支持有损压缩的标准），那么得到的缺口图片和完整图片就不一定只有缺口部分有差异了。不过好在我们知道，即使是有损压缩，也只是损失部分细节，肉眼上看到的差异并不明显，对于计算机来说，就是颜色变化并不大，对于灰度图片来说，我们可以认为是灰度值相差较小。而我们缺口位置，因为需要通过人眼能够清晰的辨别，所以它跟周围的灰度值相差应该是比较大的。于是我们就能够想到去找到这个灰度值相差的阈值，去进行区分到底是缺口还是因为有损压缩所带来的细节损失。分析大概就是到这了，下面是具体的代码： def enlarge_diff_image(bg_path=&#39;&#39;, fbg_path=&#39;&#39;, save_path=&#39;&#39;): bg_img = image.open(bg_path) fbg_img = image.open(fbg_path) img = image.new(&#39;L&#39;, (260, 160)) for i in range(260): for j in range(160): if abs(bg_img.getpixel((i, j)) - fbg_img.getpixel((i, j))) &gt; 40: img.putpixel((i, j), bg_img.getpixel((i, j))) else: img.putpixel((i, j), 255) img.save(save_path) 差异瞄点图 上面的图片就是自己坑自己的代表作，因为我将打散图还原后使用了有损压缩，最后对比的结果出来了很多干扰点，虽然通过一定的规则去定位缺口的实际位置没有太大问题，但是大家还是尽量使用无损压缩的图片进行对比会比较妥当。当然你们可以不将还原后的图片保存就直接进行对比，我这里为了方便步骤分解，躺了一次坑，学到新姿势，倒不是坏事。 无损差异瞄点图 得到这样的图片，大家想要求缺口起始位置与左边框的像素就十分简单了，当然我们还可以继续处理，将图片真正的二值化，不过最后求移动距离都是只要求第一个0点（黑点）的像素点就行，以防万一还可以加上对范围内0点（黑点）面积阈值判断。 二值化图 缺口图和完整图的缺口定位并不太难，大概到这里就可以结束了，然我们进入下一小小节。 2.2、处理截取的合成图片与定位缺口位置这部分的图片的处理和分析对我来说应该是这个小demo里面最难的点了，我知道现在的人工智能领域已经比较强大了，对很多图片内容的认知甚至超过了人类，解决这个问题或许很简单。而我则是没有深入学习过这些方面的知识，但依然想凭借自己现有的技能和思想去解决这个问题。因为前面也说过，这种方式的分析才是最接近人类行为的，只要人类认知图片内容的方式不发生变化，这里面的逻辑就还能用，于是就风风火火的开干吧。说干就干也不能立刻就写代码，毕竟我们还不知道要怎么对一张图片进行处理和分析，才能够找到那个我们需要的结果。还是先想几条路子出来吧： 缺口和周围有明显的颜色区别，我们能不能以此来确定接口位置？ 滑块和缺口都是比较规矩的拼图形状，而且y轴的范围是一样的，我们能不能在水平方向上找到两条或多条相似的竖线？ 基于上面的想法，我也是尝试做了两套方案出来。 方案一：反正就是想办法把缺口涂黑好饿好困啊，明天继续写。好了今天搬完砖回家继续码字。这一方案的最初的想法就是直接根据缺口的颜色范围来确认缺口到底在图中哪个地方，但是后面实现起来却发现是有不少问题的，到最后这个方案所得出来的位置虽有些时候确实能成功，但是准确率比较低。具体问题如下： 大家看到缺口处的颜色大概是由背景加上一层有透明度的灰色渐变图层所组成的，而组合出来的颜色很大程度取决于背景颜色，所以颜色范围就太大了，很容易把背景其他内容也选出来。 有那么两张图背景是偏暗的，如果说缺口没有明显边界的话，那么缺口其实通过肉眼也比较难观察出来，那么这种情况下我们最终描绘出来的图片可能是一大片都是缺口区域，因为缺口和背景融为一体了。 下面是这个方案的代码，没有太多次的去修改，因为颜色范围确实是不可控的，后来干脆也灰度化再对一定灰度范围描绘了。 def get_bin_image(img_path=&#39;&#39;, save_path=&#39;&#39;, t_h=150, t_l=60): img = image.open(img_path) img = img.convert(&#39;L&#39;) table = [] for i in range(256): if i in range(t_l, t_h): table.append(0) else: table.append(1) binary = img.point(table, &#39;1&#39;) binary.save(save_path) 二值化结果图 emmmm，得到这个图片，其实是比较理想的情况，缺口周围没有太多的干扰元素，定位缺口的还是比较容易的。大家认真数过可以知道，缺口和拼图的宽度（不算凹凸部分）是42个像素，而拼图与边框的左边距是6像素（拼图突出部分不在左边的情况下），那么缺口的x轴范围就应该是从第49个像素开始。那么我们在这范围内进行缺口起点的查找，可以沿用之前的想法，就是第一个满足一定规律(连续的黑点数量或者比例、范围内黑点面积占比等等)的黑点，我们可以认为他比较大概率是缺口的起点。具体的代码： def get_x_point(bin_img_path=&#39;&#39;): tmp_x_cur = 0 img = image.open(bin_img_path).load() # 缺口出现范围大概在x轴[49-52]-220,y轴15-145 for y_cur in range(15, 145): b_acc = 0 tmp_x_cur = 0 for x_cur in range(49, 220): if img[x_cur, y_cur] == 0: if b_acc == 0: tmp_x_cur = x_cur b_acc += 1 else: if b_acc in range(36, 44): return tmp_x_cur - 40 + b_acc else: b_acc = 0 return tmp_x_cur 这个函数我后来没有继续去优化了，因为觉得想到了方案二的一些雏形，就开始着手方案二了。这个函数定义的规则相当的简陋，即使排除了上面提到的问题，有的时候都还是不能准确判断起始位置。大家有兴趣的话可以自己定制一些规则，尝试提升这种方案的成功率。 方案二：对图片所有内容进行描边 关于这个方案，其实一开始并没有觉得比第一个方案好到哪里去，最后试验得出的结果却较为满意，我认为应该还是归功于较为完善的规则。无论是哪个方案，只要是模仿人类认知行为的，都有一定的可行性，尽管方式上有区别，但是这就跟人类认知事物的过程是一样的。例如我们在认识鸡这种动物的时候，既记住了它们的棕黄色的毛，红色的冠，也记住了它们的外形，那我们在下次看到一只乌鸡的时候，我们能够通过它的外形确认这是一只鸡，只是一只颜色不一样的鸡而已，没人会因为它的毛是黑色的而觉得它是一只黑猫。通过捕捉人类区分事物特征点的方式去思考以及编码，才是解决这次实验的关键。 3、将拼图移动到缺口处]]></content>
      <categories>
        <category>有趣</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo踩坑记]]></title>
    <url>%2F2018%2F09%2F27%2Fhexo%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[hexo的搭建和使用十分的方便，搭配github page食用更佳。github上有很多绚丽的hexo主题，大家可以按需搭配。虽说hexo+github page搭建个人博客很方便快捷，但如果你需要较多的个性化定制，坑总是会踩的。本文主要遇到的各种坑以及记录简单的操作步骤，如果需要详细的安装部署教程请点击传送门离开。 安装hexo 如果你不知道或者未安装 npm ，点击此处了解以及下载。 npm i -g hexo-cli 说到npm我在后面挖到了一个坑，这个坑以前已经挖过，这里又遇到了，有必要记下来。如果你跟我一样是在使用Windows 10 + VirtualBox (VBox) + Vagrant + Laravel Homestead + 共享目录这样的环境做开发的，需要注意。 在上述环境中使用npm会有比较多意料之外的状况，大部分stackoverflow上都有解决方案，但这次遇到的error “ETXTBSY: text file is busy” on npm install弄了一段时间仍然没解决，把npm搞坏后还是换到windows环境去了。 虽然没解决，但还是推荐一下比较靠谱的解决方案。 快速搭建hexo init [folder] //初始化，新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站 cd folder //进入网站根目录，如果没有设置 folder ，则不需要该步骤 hexo g //generetor的缩写，生成静态文件。 hexo s //server的缩写，启动服务器。默认情况下，访问网址为： http://localhost:4000/。 主题。。。待续]]></content>
      <categories>
        <category>挖坑</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux添加服务到开机自动启动]]></title>
    <url>%2F2018%2F09%2F27%2FLinux%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%88%B0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[Systemd 是 Linux 系统中最新的初始化系统，Systemd 服务文件以 .service 结尾。一些使用包管理工具安装的软件会自动建立 .service 服务文件，路径在 /lib/systemd/system/ 下，但自行建立及管理的文件建议放在 /etc/systemd/system/ 目录下。内容以 supervisor 为例： [Unit] Description=Supervisor process control system for UNIX Documentation=http://supervisord.org After=network.target [Service] ExecStart=/usr/bin/supervisord -n -c /etc/supervisor/supervisord.conf ExecStop=/usr/bin/supervisorctl $OPTIONS shutdown ExecReload=/usr/bin/supervisorctl -c /etc/supervisor/supervisord.conf $OPTIONS reload KillMode=process Restart=on-failure RestartSec=50s [Install] WantedBy=multi-user.target 参数说明： [Unit] Description：描述服务 Documentation：参考资料 After：描述服务类别 [Service] Type：是后台运行的形式 ExecStart：服务的具体运行命令 ExecReload：重启命令 ExecStop：停止命令 KillMode：daemon终止时所关闭的程序 Restart：触发重启 RestartSec：重启等待时间 TimeoutSec：无法顺利启动强制关闭时间 注意：[Service]的启动、重启、停止命令全部要求使用绝对路径 [Install] 运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3 如过想要某些服务开机启动，例如以 php-fpm 为例，编写service： sudo vi /etc/systemd/system/php7.1-fpm.service [Unit] Description=The PHP 7.1 FastCGI Process Manager Documentation=man:php-fpm7.1(8) After=network.target [Service] Type=notify PIDFile=/run/php/php7.1-fpm.pid ExecStart=/usr/sbin/php-fpm7.1 -R --nodaemonize --fpm-config /etc/php/7.1/fpm/php-fpm.conf ExecReload=/bin/kill -USR2 $MAINPID [Install] WantedBy=multi-user.target 随后如果 php-fpm 在运行则先将其关闭，运行： systemctl daemon-reload systemctl start php7.1-fpm.service 测试能够成功开启服务了，就可以将服务设置为开机启动： systemctl enable php7.1-fpm.service 常用命令systemctl daemon-reload systemctl list-units --type=service systemctl list-unit-files --type=service systemctl start unit.service systemctl stop unit.service systemctl restart unit.service systemctl enable unit.service systemctl disable unit.service systemctl is-enable unit.service systemctl is-active unit.service systemctl status unit.service]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO模型笔记]]></title>
    <url>%2F2018%2F09%2F27%2FIO%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[IO Model常见IO模型 blocking IO nonblocking IO IO mutiplexing(select &amp; poll) signal driven IO asynchronous IO(the POSIX aio_functions) 一个基本的IO，它会涉及到两个系统对象，一个就是系统内核，另一个是调用这个IO的对象。当一个read操作发生时，会经历以下阶段： 通过read系统调用向内核发起读请求 内核向硬件发送读指令，并等待读就绪 内核把将要读取的数据复制到描述符所指向的内核缓存区 将数据从内核缓存区拷贝到用户进程空间中 同步与异步 同步和异步关注的是消息通信机制 注：同步IO过程由进程处理，异步IO交由内核处理IO 阻塞与非阻塞 阻塞和非阻塞关注的是程序在等待调用结果时的状态 1，2，3，4属于同步IO，5属于异步IO AIO异步非阻塞IO，适用于连接数多且IO时间长的架构，如相册服务器，JDK7开始支持 NIO同步非阻塞IO，适用于连接数多且轻操作（IO?）的架构 BIO同步则色IO，适用于连接数少且固定的架构 一般来说，IO主要有两种情况（服务器）：一是来自网络的IO，二是文件的IO。windows提供异步IO，Linux提供epoll模型给网络IO，文件IO则提供AIO epoll,select/poll 本质上都是同步IO，自己处理IO过程，但是epoll优化了轮询操作，使用callback机制响应。 额外提供Edge Triggered，用户空间可能缓存IO状态，减少epoll-wait／epoll-pwait调用 level triggered &amp; edge triggered LT事件不会丢弃，只要读buffer里面有数据可以让用户读，就会不停的通知。而ET则只发在事件发生之时通知。 select缺点： 每次调用，都需要把fd集合从用户态拷贝到内核态，fd多事件开销大 每次都要遍历进入内核的fd，开销也很大 select支持fd数量太小，默认1024 poll与select只在fd集合的结构上面有区别 epoll对select缺点的改进 新事件注册到epoll句柄中，会把所有的fd拷贝进内核，而不是在epoll_wait时重复拷贝 为fd指定回调函数，设备就绪，调用回调函数唤醒等待者，并将fd加入就绪链表 最大的限制很大程度上跟系统内存大小有关 消息传递：mmap加速 总结 select、poll都需要轮询遍历所有fd，而epoll只需要读取就绪链表 select、poll每次调用都copy一次fd，并往设备队列上挂。而epoll只要copy一次fd，并只往自己的等待队列上挂一次即可]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Standard Recommendation]]></title>
    <url>%2F2018%2F09%2F27%2FPHP-Standard-Recommendation%2F</url>
    <content type="text"><![CDATA[非官方规范。 PSR-0(AutoLoading Standard)(14年10月21日起标记为deprecated，由PSR-4代替) 完全合格的命名空间和类名必须有以下结构&quot;\&lt;vendor name&gt;\(&lt;Namespace&gt;)*&lt;Class Name&gt;&quot; 每个命名空间必须有顶级命名空间(&quot;Vendor Name&quot;) 每个命名空间可以有任意多个子命名空间 每个命名空间在被从文件系统加载时必须被转换为操作系统的路径分隔符 每个”_“字符在类名中被转换为DIRECTORY_SEPARATOR。”_“在命名空间中没有明确含义 符合命名标志的命名空间和类名必须以”.php”结尾来加载 VendorName、命名空间、类名可以由大小写字母组成，其中命名空间和类名是大小写敏感的以保证多系统兼容 PSR-1(Basic Coding Standard) 源文件必须只使用以下这两种标签&lt;?php 和 &lt;?= 源文件中php代码的编码格式必须只适用不带BOM的UTF－8（BOM——字节顺序标记） 一个源文件建议只用来做声明（类、函数、常量等）或者只用来做一些引起副作用的操作（如输出信息，修改配置文件等），但不应该同时做这两件事 命名空间和类必须遵守PSR-0 类名必须使用StudlyCaps写法 类中的常量必须只由大写字母和下划线组成 方法名必须使用camelCase写法 PSR-2(Coding Style Guide) 代码必须遵循PSR-1 代码必须使用4个空格进行缩进，而不是制表符 一行代码的长度不应该有硬限制，软限制为120个字符，建议每行小于80 在命名空间声明下必须空一行，use下同理 类的左、右花括号必须各自成一行 方法的左右花括号都必须各自成一行 所有属性、方法必须有可见性声明；abstract和final必须在可见性声明前，static必须在可见性声明后 在结构控制的关键字后必须空一格；函数调用后面不可有空格 结构控制关键字左花括号必须同一行，右花括号必须放在代码主体下一行 控制结构的左花括号之后不可有空格，右花括号之前也不可有空格 PSR-3(Logger Interface) LoggerInterface暴露八个接口用来记录八个等级(debug,info,notice,warning,error,critical,alert,emergency)的日志 第九个方法是log，接受日志等级操作为第一个参数。用一个日志等级常量来调用这个方法必须和直接调用指定等级方法的结果一致。用一格本规范中来定义且不为具体实现所知的日志等级来调用该方法必须跑出一个PSR\Log\InvalidArgumentException 不推荐使用自定义的日志等级，除非你非常确认当前类库对其支持。 PSR-4(Improved AutoLoading)(兼容PSR-0) 术语［类］是一个泛称，它包含类、接口、trait及其他类似结构 完全限定类名应该如下范例&lt;NamespaceName&gt;(&lt;SubNamespace&gt;)*&lt;ClassName&gt; 完全合规类名必须有一格顶级命名空间 完全合规类名可有多个子命名空间 完全合规类名应该有一格终止类名 下划线在完全合规类名中是没有特殊含义的 字母在完全合规类名中可以是任何大小写组合 所有类名必须以大小写敏感的方式引用 当完全合规类名载入文件时： 在完全合规类名中，连续的一个或几个子命名空间构成的命名空间前缀（不包括顶级命名空间分隔符），至少对应一格基础目录 在［命名空间前缀］后的连续子命名空间名称对应一个［基础目录］下的子目录，其中的命名空间分隔符标示目录分隔符。子目录名称必须和子命名空间名大小写匹配 终止类名对应一个以.php结尾的文件。文件名必须和终止类名大小写匹配 自动载入器的实现不可以抛出任何异常，不可以引发任何等级的错误，也不应该有返回值]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来到我的博客 public class HelloWorld { public static void main(String[] args) { System.out.println(&quot;Hello,World!&quot;); } } #include &lt;stdio.h&gt; int main() { printf(&quot;Hello,World!&quot;); return 1; } var sys = require(&quot;sys&quot;); sys.puts(&quot;Hello,World!&quot;); &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;This is the first program!&lt;/h1&gt; &lt;p&gt;Hello,World!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>闲聊</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
</search>
